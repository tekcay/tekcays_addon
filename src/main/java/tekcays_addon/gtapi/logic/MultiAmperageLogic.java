package tekcays_addon.gtapi.logic;

import gregtech.api.capability.IEnergyContainer;
import gregtech.api.capability.impl.MultiblockRecipeLogic;
import gregtech.api.metatileentity.multiblock.RecipeMapMultiblockController;
import gregtech.api.recipes.Recipe;
import tekcays_addon.gtapi.recipes.recipeproperties.MultiAmperageProperty;

import javax.annotation.Nonnull;

public class MultiAmperageLogic extends MultiblockRecipeLogic {

    public MultiAmperageLogic(RecipeMapMultiblockController tileEntity) {
        super(tileEntity);
    }

    public boolean checkRecipe(@Nonnull Recipe recipe, boolean consumeIfSuccess) {
        return recipe.getProperty(MultiAmperageProperty.getInstance(), 0L) >= getEnergyContainer().getInputAmperage();
    }

    @Override
    public boolean drawEnergy(int recipeEUt, boolean simulate) {
        long resultEnergy = getEnergyContainer().getEnergyStored() - (recipeEUt);
        if (resultEnergy >= 0L && resultEnergy <= getEnergyCapacity()) {
            if (!simulate) getEnergyContainer().changeEnergy(-recipeEUt);
            return true;
        } else return false;
    }

    @Override
    protected boolean hasEnoughPower(@Nonnull int[] resultOverclock) {
        // Format of resultOverclock: EU/t, duration
        int totalEUt = resultOverclock[0] * resultOverclock[1];

        //RIP Ternary
        // Power Consumption case
        if (totalEUt >= 0) {
            int capacity;
            // If the total consumed power is greater than half the internal capacity
            if (totalEUt > getEnergyCapacity() / 2) {
                // Only draw 1A of power from the internal buffer to allow for recharging of the internal buffer from
                // external sources
                capacity = resultOverclock[0];
            } else {
                // If the total consumed power is less than half the capacity, just drain the whole thing
                capacity = totalEUt;
            }

            // Return true if we have enough energy stored to progress the recipe, either 1A or the whole amount
            return getEnergyStored() >= capacity;
        }
        // Power Generation case
        else {
            // This is the EU/t generated by the generator
            int power = resultOverclock[0];
            // Return true if we can fit at least 1A of energy into the energy output
            return getEnergyStored() - (long) power <= getEnergyCapacity();
        }
    }


}
